现代密码学

评分
    三次大作业 30%
    考勤和小测 10%
    开卷考试 60%

------------------------------------------------------------------------------
历史
    隐写术
        隐藏消息 (信息的载体) 本身, 相对于密码隐藏有效信息
    Substitution 替换
        单表 / 多表
        密码盘
    Transposition 置换
        轮转机
    > Enigma
        message -> 接线板: 随机交换6对字母
            [相当于单表代换]
        -> 3个'扰频器': 替换后替换函数也会变换 (shift-by-one)
            [通过变动的替换函数, 提供频率扰动, 防止频率分析]
            [相当于26*26*26多表代换]
        -> 反射器
    对称密码体系
        e.g. DES, AES
    公钥密码体系 (非对称密码体系)
        e.g. DH, RSA, ECC
    量子密码体系
        主要是量子密钥分发

术语
    发送方 Alice
    接收方 Bob
    窃听者 Eve
    不安全信道: 密码分析
    消息认证码: 保证消息来自通讯双方, 抗篡改, 通常是使用对称密钥加密消息哈希
    数字签名: 保证消息来自特定的某一个人, 抗抵赖, 通常是私钥加密消息哈希
    证书: 签名了的公钥, 确保没有第三方伪造证书

基本原则
    算法的保密非常脆弱: 相对于密钥, 算法很难保密, 一旦泄露代价很大
    Kerckhoffs Principle: 一个密码系统的安全性不在于对加密算法进行保密,
        而仅在于对密钥的保密
    一次一密: 绝对安全, C = M xor K, K 和 M 一样长而且只使用一次

密码学的分支
    编码:   主要是设计密码
    分析:   主要是对密码的破解
    密钥管理: 密钥整个生命周期

密码分析
    唯密文
        只知道 (一系列) 的密文, 没有其他信息
    已知明文
        知道当前密钥下的一些明密文对
    选择明文
        在当前密钥下, 能选择一些明文得到其对应的密文
    选择密文
        在当前密钥下, 能选择一些密文得到其对应的明文
        一般这里的密文不是随便选取的
    最后两种一般评估密码算法的强度

------------------------------------------------------------------------------
古典密码学
    设计原则主要就是 置换 和 代换

置换密码
    密钥
        1..n 上的置换 pi(i)
    加密
        C_i = P_{pi(i)}
    密码棒, 列密码, Naive分组置换

    分析方法:
        频率信息确定算法是置换算法
        唯密文攻击: 暴力搜索, 密码空间比较小; 查字典
        已知明文攻击: 很简单可以恢复密钥

代换密码
    恺撒密码: 平移代换密码.
        c_i =  (p_i + K) mod 26
        知道密码算法是 Caesar 则直接测试 25 种可能
        不知道密码可以通过频率分析确定
    Naive代换: 单表静态代换
        a in ALPHABET -> b in ALPHABET, 通过一个双射
        密钥可以是一个单词, 方便古人记忆
        暴力破解很困难, 密钥空间很大.
        频率分析, k-gram 频率分析
    Vigenere: 多表代换
        c_i = (m_i + k_{i mod lk}) mod 26
        和现代思想的对比 -> 流密码: 先产生密钥流
        密钥空间大小很大: 无法穷举搜索
        如果知道密钥长度, 则容易破解
        Kasiski测试:
            相同的明文被加密成相同的密文段, 则间距是密钥长度倍数
            -> 搜索长度较长的相同密文段, 假设他们是相同明文加密所得,
              则密文段间距离是 lk 的倍数
              得到足够多组密文段后就可以 lk | gcd(间距)
        重合指数法:
            Ic(x) 是 x 中两个随机元素相同的概率
            随机的 Ic 显著低于正常英语串的 Ic
            枚举密钥长度, 长度正确时则
              c_1, c_{1+lk}, c_{1+2lk} ...
              的 Ic 应当接近正常英语串的 Ic
        弱点
            密钥长度 < 明文长度
        加强 Vigenere
            密钥产生: 密钥和消息一样长
            密钥随机: 每次加密使用不同的密钥
            -> 这就是一次一密
    Playfair
        代换基于双字母对 (2gram)
        和现代思想的对比: 多字母加密 -> 块密码
    一次一密
        无论有多少计算资源, 都无法破解
        given C: forall T: exists K: Encrypt_K[T] = C
        已知任何的密文, 都无法推出明文的信息
        密文无法泄露关于明文的信息:
            Pr{P=p' | C=c'} = Pr{P=p'}
            证明 (Bayes定理)

密码体系的安全性
    * 无条件安全性    无论计算资源多少都无法破解. OTP
    * 计算安全性      在可能的计算能力限制下, 破解的概率很小
                        即 ``实践中'' 无法控制
    * 可证明安全性    可以归约到数学难题. i.e. 不弱于一个数学难题.
                        事实上是给安全性提供 ``证据''
    现有的计算资源
        e.g. 每秒 十亿亿次计算 ...
        密钥空间只要应有 2**128 大小的计算空间
            i.e. 密钥长度需要至少 128 位
    密钥空间过小, i.e. 短密钥是危险的
        则无论已知明文还是唯密文都可以通过枚举密钥得到原文的性质
            (所谓明文性质, 包括明文空间上的概率分布也算,
            得到明文空间的真子集也算)
    归约方法 (概率性的描述)
        A 攻破密码的成功率是 e
        A' 要解决难题 X
        如果通过调用 A, A' 以不可忽略的概率解决 X
    实际的对称密码要求
        * 计算安全: 唯密文 / 选择明文
        * 方便实用: 不用使用冗长密钥, 不必频繁更换, 计算速度快
    现在来看, 序列密码的可信度被认为较低 (虽然速度较快).
        一般使用分组密码较多.

------------------------------------------------------------------------------
分组密码
    概念
        一次加密一大块数据
    历史
        DES (Feistel), 3DES, AES (SPN, 2001 yr)
    迭代结构
        密钥 -密钥生成-> 密钥组
        m 迭代 -> a1 -> a2 ... -> c

分组密码架构
    Feistel结构 (1973 yr)
        将输入分成左右两半, 第 k 轮完成
            L_t = L xor F(K_k, R_i)
            L_o = R_i
            R_o = L_t
        加解密可以使用同一套设备, 除了密钥组顺序相反
        变种
            * 非平衡 Feistel e.g. skipjack
            * 多叉 Feistel
        安全性
            轮函数 F 是安全的伪随机函数, 则
            Feistel 结构在很浅的轮数就能形成 [强的] 伪随机置换
            (事实上简单的 F 不满足伪随机, 所以轮数在实际中并不浅)
    Substitution Permutation Network
        每一轮
            in -> xor K_k -> S-box -> P-box -> out
        S-box的属性
            * 简单的单表代换, 一般较小 -> 易于实现
            * 输出中任何比特与所有比特都有关系
            * 输入即使只有 1 比特改变, 输出有很多比特改变 (扩散)
        加解密不能使用同一套设备

DES
    基本框架
        M -> 起始置换 -> 16 轮 -> 末置换 -> C
    F 函数
        in (L half) -> xor K_k
            -> S-box (S-box in=6b, out=4b)
            -> P-box (in=32b, out=32b)
            -> out
        其中, S-box 的设计由其需要的属性决定,
        在此基础上加上一些酒后涂鸦和上司的要求
    密钥生成
        移位和置换

SM4
    基于 4 分支的 Feistel (Generalized Feistel)

2-DES
    M - Ek1 >- Ek2 > C
    被 MITM 破解.
    考虑选择明文攻击 (给定任何 M 可求出 C)
    选定一个 M, 枚举所有的 k1 计算 Ek1(M) 得到 {Ek1(M)}
        可以看出, {Ek1(M)} 大小约为 |{k1}| = 2**56
        (Ek1(M) 是 64 位的)
    将这些 Ek1(M) 用合适的数据结构组织起来,
    可以在常数或者对数时间内查找是否存在
    然后枚举 k2, 每次计算出 Dk2(C) 可以迅速查找是否有 Ek1(M) == Dk2(C)
    对于 2-DES, (使用MITM) 可以在 2**56 + 2**56 时间和 2**56 空间内被破解
    而暴力需要 2**112 时间 (和很少空间)

3-DES
    M - Ek1 >- Ek2 >- Ek3 > C
    也被 MITM 破解, 可以在 2**56 空间和 2**112 时间内被破解
    但是是计算安全的

AES
    基于 SPN
    状态
      S =   s0   s4   s8   s12
            s1   s5   s9   s13
            s2   s6   s10  s14
            s3   s7   s11  s15
    伪代码
        AES(P) -> C
            S = P
            add_round_key(S, w[0])
            for r=1..Nr-1
                sub_bytes(S)
                shift_rows(S)   从0到3第 i 行作为整体 (32位字) 左移 i 位
                mix_columns(S)  ... GF 上乘法
                add_round_key(S, w[r])
            sub_bytes(S)
            shift_rows(S)
            # 最后没有 Mix Columns
            add_round_key(S, w[Nr])
            return C
    GF(256) 上乘法
        使用多项式表示元素, 乘完之后需模二元域GF(2)上一个8次不可约多项式的乘积
        AES 中是 x8 + x4 + x2 + x1 + x0
        e.g.
          0x57 mul 0x83 = (x6+x4 + x2+x1+x0) mul (x7 + x+1)
                            mod (x8+x4+x2+x1+x0)
                        = x7 + x6 + 1
                        = 0xc1

分组密码的工作模式
    分组密码实际中的使用模式
    对任意长的明文如何加密

    ECB: 明文的 N 个分组使用统一密钥加密和解密
        -> 可以并行, 效率高, 实现简单
        -> 相同的明文分组导致相同的密文, 变成单表代换
        -> 只能使用短消息, 或者高度随机的数据
        错误敏感性:
            一位传输错误导致一个分组无法正确解密
        [ECB.png]

    CBC: 每一组明文加密前, 先和前一组密文异或
        IV: 无需保密, 但是需要随机, 抗篡改
        -> 加密不能并行; 解密可以并行
        错误敏感性
            一位传输错误导致两个分组无法正确解密
            这个错误所在的分组和下一个分组
        [CBC.png]
        CBC 是应用最广的工作模式.

    CFB: 从 IV 生成一个密钥流, 每次加密 r 位明文,
        直接抽取加密算法得到前 r 位 与明文异或,
        之后得到的 r 位密文又压入密钥流中
        -> 加密分组长度可变, 支持任意长度的明文, 加密长度不变
        -> 一位传输错误导致若干个分组无法正确解密
        -> 无法并行 / 效率低
        错误敏感性
            一位传输错误导致 n/r+1 个分组无法正确解密
        通常应用在需要加密解密前后数据大小不变的场合, 如数据库和硬盘加密
        [CFB.png]

    OFB: 类似 CFB, 但是每次生成密钥仅仅依赖上次密钥
        IV: 每次使用不同的 IV, 虽然不用保密
        -> 1 bit 的错误解密后也只会有 1 bit 的错误
        容易出现小圈 e.g. S1 -> S2 -> ... -> S1
            这个圈的大小平均为 (生日攻击) 2**(sizeof(S1)/2)
        错误敏感性
            一位传输错误导致解密后一位错误
        [OFB.png]

    CTR: 密钥流通过 E_K[一个计数器] 生成, 密钥 K 对于每个计数器是一样的
        -> 加解密都可以并行
        错误敏感性
            一位传输错误导致解密后一位错误
        [CTR.png]

填充
    ECB 和 CBC 需要填充, CFB, OFB 和 CTR 不需要填充
    TODO: 为什么 CTR 不需要填充
    明文填充
        -> 填充: 位填充 / 字节填充; 随机填充 / 零填充; 是否包含填充长度
        注意, 无论分组满不满, 都要填充 (不然数据是填充还是明文?)
    cipher text stealing:
        在 EBC 等模式中
        ECB:
            考虑最后两个分组 Pi 和 P{i+1} 其中 P{i+1} 长度不满一整個分组
            那么他们加密得到的结果是
                Pi                          P{i+1}
                v
                加密
                v
                Ci = Ci^(1) || Ci^(2)               其中 Ci^(2) 和 P{i+1} 一样长
                V                           V
                E(P{i+1} || Ci^(2))         Ci^(1)
        CBC:
            同上
                Pi                          P{i+1}
                                            Ext(P{i+1})     Ext 就是加上 padding
                v
                加密
                v
                Ci
                V
                E(Ci xor Ext(P{i+1}))       Shr(Ci)
                                                最后 padding 的长度那一部分去掉
    存储加密
        和通信加密不同
        一般模型考虑磁盘上的存储加密, 以块为独立并行的单位,
        并且元信息只考虑块号
        -> XTS-AES

密码攻击
    时间复杂度通常使用执行的加解密次数来计算

Padding oracle attack
    给予服务器给出的 padding 错误信息恢复明文

通用密码分析
    强力攻击!
        穷举密钥
        字典攻击 对某个 K, 存储 2**n <P, C> pairs
        查表攻击 对某个 P, 存储 2**k <K, P> pairs
    T-M Tradeoff
        明文固定, 密文已知, 加密算法已知, 希望恢复密钥

DES 差分分析
    重绘 DES 结构 (只考虑一轮)
        +-----------------------------+--------------------------------+
        |            L                |               R                |
        +--------+--------------------+-----------------+--------------+
                 |                                      |
                 |                                      |
                 |                                      |
                 v                                      |
                xor <-- P <-- CS <-- xor <---- EP <-----+
                 |                    ^                 |
                 |                    |                 |
                 |                    |                 |
                 |                  K_i            +----+
                 |                                 |
                 +---------------------------------+----+
                                                   |    |
                 +---------------------------------+    |
                 |                                      |
                 v                                      v
        +-----------------------------+--------------------------------+
        |            L                |               R                |
        +--------+--------------------+-----------------+--------------+
    线性和非线性部件
        xor, P, EP 是线性部件
            如 DELTA $ xor i = xor $ DELTA i
            DELTA 是对不同的输入做减法 (减法在这里是 xor)
        CS (即 compressive s-box) 是非线性部件, 没有如上的性质
    CS 的性质
        对于每一个 s-box (图中 CS 是多个 s-box)
        考虑 DELTA $ CS a, 我们可以构建一张表
            <DELTA $ CS a, CS $ DELTA a>  ->  a
        就是说, 已知 CS 的输入和输出的差分, 我们可以得到有那些可能的输入
            能造成这样的输入输出差分
        列出表发现, 相当一部分 输入差分和输出差分的组合是不可能的.
    破解最后一轮的密钥
        考虑每一个 s-box.
        s-box 的输入差分可以从 Lt 差分得到, 输出差分可以从 Rt 差分得到,
        这样我们就可以得到输入输出差分对. 查表得到可能的输入, 于是得到密钥
        在这个 s-box 范围的部分.
    推广到更大轮数的 DES
        # TODO 课件写的啥?

随机数 RNG
  	性质
        * 随机性
        * 不可预测性
        * 不可重现性
        愈来愈强

  	种子 -> 内部状态 <自更新> -> 输出序列
  	* 线性同余
  	* 单向哈兮
      hash(istate++)
  	* 密码法
      E_Prk (istate++)

LFSR
    布尔函数的线性递推表达式
        an = c1 a{n-1}  xor   c2 a{n-2}   xor ...
    多项式表示
        f(x) = 1 + sum{i>0, i<=l} ci x^i
        用 <l, f> 来表示一个 LFSR
    m 序列
        l 级 LSFR 最长周期是 2^l - 1, 达到这个周期成为 m 序列
        f 生成 m 序列当且仅当 f 是一个不可约多项式
    周期序列的 Golomb 随机性
        1. 一个周期中 0 1 个数相差不超过 1
        2. 长度为 k 的游程占游程总数 1/2**k
    产生序列需要
        1. f 函数 (或者递推函数)
        2. 对于 <l, f> 的 LFSR 需要前 l 位
    从序列的一个周期产生 <l, f>
        1. 已知 l : 解方程
        2. BM 算法
              def evalf(f, i):
                  rv = 0
                  for j in range(1, len(f)):
                      rv = rv ^ (a(i-j) & f[j])
                  return rv
              for i, ai in enumerate(_a):
                  d = evalf(f[i], i) ^ ai
                  if d == 0:
                      f += [f[-1]]
                      l += [l[-1]]
                  else:
                      if l[-1] == 0:
                          l += [i+1]
                          fnp1 = [0 for i in range(l[-1]+1)]
                          fnp1[0] = fnp1[i+1] = 1
                          f += [fnp1]
                      else:
                          m = i-1
                          while (m > 0) and (l[m] == l[i]):
                              m -= 1
                          f += [add(mul(f[m], x^(i-m)), f[i])]
                          l += [max(l[i], i+1-l[i])]
    通过 LFSR 建立密钥流
        LFSR1   -> +---+
        LSSR2   -> | F +---> K
        ...        |   |
        LFSRk   -> +---+
        F 是一个非线性函数, 提高输入的线性复杂度和保持伪随机性

------------------------------------------------------------------------------
哈希函数
定义
    把任意长的消息压缩成 l 位 {0,1}^* -> {0,1}^l
    注意压缩函数是把 l+m 位的映射到 l 上,
        可以使用 Merkle 的迭代算法用无碰撞的压缩函数实现无碰撞的哈希函数,
        成为 MD 结构, 这是现在许多算法的基石.
性质
    * 可计算性
    * 抗原像: 给 H(x), 计算得到 x 是困难的
      Brute force O(2^l) with 1-e^{-1} probability.
        (Euler's equality: (1-x^{-1])^{x} -> e^{-1})
    * 第二抗原像: 给 H(x), 求任何一个 z 使得 H(z) = H(x) 是困难的
    * 抗碰撞: 难以发现 x, y 使得 H(x) = H(y)

结构
    块 Hash (MD 结构, Wide-pipe结构)
         +----------------+-------------------+---
         | 消息分块       | 消息分块          |  ...
         +-+--------------+----+--------------+---
           |                   |
           |                   |
           |      +---         |      +---
           +----->|   \        +----->|   \
                  |    \              |    \
         +---+    |     \    +---+    |     \
         |IV +--->|压缩 +--->|IV +--->|压缩 +---> ...
         |   |    | 函数|    |   |    | 函数|
         +---+    +-----+    +---+    +-----+
        特点: 压缩函数抗碰撞 <=> 如上得到的哈希函数抗碰撞
        攻击: 加长攻击
    海绵结构
        整个哈希过程分成两部分
        1. 从 IV 开始, 每次接受输入的一小部分, 之后做 F 变换
        做完 1 相当于把输入吸收到了我们的状态中
        2. 每次输出状态的一小部分, 然后做 F 变换
        以上 F 是一个双蛇, 不改变长度

寻找 Hash 碰撞
    * 暴力穷举
    * 生日攻击: 需要 2^{n/2} 的存储
    * 随机路径算法:
        选定 X0, 之后 X{i+1} = H(Xi)
        使用 Floyd's 双指针算法可以只用 O(1) 空间:
            最开始 P0, P1 都是 X0
            每次迭代, P0 = H(P0), P1 = H(H(P1)), 相当于 P1 比 P0 快一倍
            当 P1, P0 相遇的时候, 说明找到碰撞点
            这时 P1 保持在碰撞点, P0 回到 X0
            之后每次迭代, P0 = H(P0), P1 = H(P1), 相当于速度相同
            当 H(P0) = H(P1) 时, 就找到了哈希的一个碰撞

MD5
    使用 MD 结构, 消息分块 512 位, IV 状态 128 位.
    4 轮, 每轮对状态做 16 次变换

SHA
    使用 MD 结构, 消息分块 512 位, IV 状态 160 位.
------------------------------------------------------------------------------
消息认证码

认证
    * 消息完整性: 不被篡改
    * 消息来源: 对发消息的人的认证
    * 抗抵赖性, 抗重放性

针对消息完整性的认证
    * 安全通道传输消息哈希
    * 不加密消息, 加密消息哈希形成 MAC, 附在消息后面
    * 加密消息和消息哈希, 一起传输

消息真实性的认证
    * MAC: E_SK(M), SK 是共享的密钥
        数据完整性, 消息来源认证, 不能实现数字签名
        攻击: 伪造原文; 密钥恢复攻击; 重放攻击;
    * 数字签名 (见后)

------------------------------------------------------------------------------
公钥密码体制

对称密钥密码系统的缺陷
    * 密钥必须经过安全的信道分配
    * 无法用于数字签名
    * 密钥管理复杂, 密钥的数量: O(n^2)

对称体制下的解决方案: 密钥分发中心
    所有人和 KDC 有一个共享密钥, 并且建立安全信道
    A 和 B 通信:
        A 向 KDC 请求
        KDC 鉴别 A 身份, 生成随机密钥分发给 A 和 B
    * KDC 负担重, 安全级别高

公钥密码体系带来的
    * 加解密
    * 数字签名
    * 开放环境中交换秘密的可能

实际中的使用
    签密
          签名和加密同时进行
          a           签名           加密             不安全信道
          M    ->    E_KRa    ->    E_KUb    ->    C    ->
          不安全信道         解密         验证签名        b
          ->     C    ->    D_KRb    ->    E_KPa    ->    M
    混合加密
      通过公钥密码发送密钥, 使用这个密钥做对称密码加密
      提供了安全信道

------------------------------------------------------------------------------
公钥密码数学基础
    * 素数, Fermat 小定理, Euler 函数和降幂公式, 中国剩余定理
        a^m equiv a^{m mod phi(n) + phi(n)}   pmod n
    * Miller-Rabin 算法
        有两个部分组成
            Fermat 小定理
                forall a : a^{p-1} equiv 1   pmod p
            Z_p 只有平凡 1 的剩余根
                b^2 equiv 1  pmod p   <=>   b = pm 1  pmod p
        基本算法
            随机选 a, 希望计算 a^{p-1} mod p
            分解 p-1 = y 2^r, r 尽量大 i.e. y 是奇数
            按照 a^{p-1} = sqr^r(a^y) 计算 a^{p-1},
                过程中平方时检查是否遇到非平凡 1 的二次根
            最后检查 a^{p-1} mod p 是否等于 1
    * 二次剩余

RSA算法
    算法
        有
            p, q: 大素数, 保密
            n: n = pq
            e: e \perp phi(n), 一般是小整数
            d: de mod phi(n) = 1
        则
            KU = n, e
            KR = d
    加解密
        要求消息 0 <= m < n:
        E_{KU}(m) = m^e mod n
        D_{KR}(c) = c^d mod n
    强度
        RSA 不强于分解 (至今没有说明不弱于)
    其他性质
        * 比 DES 慢 100 ~ 1000 倍
    攻击
        分解攻击
            分解得到 n = pq, 之后得到 phi(n) = (p-1)(q-1),
            然后通过 e 得到 d.
        同模攻击
            将同样消息加密发给多个人, 模数相同
            Eve 得到 m^e1, m^e2 ...
            那么假设 e1, e2 互素, 就有 x1e1 + x2e2 = 1 (这里没有模)
            那么容易恢复出 m: m = (m^e1)^x1 * (m^e2)^x2 (mod n)
        小指数加密
            假设 e 都取 3, Eve 得到
              m^3 mod n1, m^3 mod n2 ...
            那么通过 CRT 得到 m^3, 然后开三次方得到 m

Diffie-Hellman 密钥交换
    有
        q: 素数
        g: Z^*_q 的原根
    通过以下步骤, A, B 在不安全的信道上也能建立共享秘密
        A                         B
        选择一个私有的 XA         选择私有的 XB
        计算YA = g^XA 公开        计算 YB = g^XB 公开
              共同秘密 K = YB^XA = YA^XB = g^XAXB

二次剩余加密
    模素数
        每个二次剩余有且只有两个平方根
        J_p(x) = x是二次剩余 ? 1 : -1
        J_p(x) = x^{(p-1)/2}
        J_p(xy) = J_p(x) J_p(y)
        如果 p+1 equiv 0 mod 4, 那么 x^{(p+1)/4} 是 x 的一个平方根
    模 N = pq
        y 是 N 的二次剩余 <=>
            y mod p 是 p 的二次剩余, y mod q 是 q 的二次剩余
        J_pq(y) = J_p(y) J_q(y)
        J_pq(xy) = J_pq(x) J_pq(y)
        出现新的一类数, J_pq = 1 但是不是二次剩余, 用 QNR^{+1} 表示
        已知 N 的分解 pq 时, 二次剩余判定是容易的,
            只知道 N 时, 二次剩余判定是困难的
    Rabin 方法
        有
            KR  p q 素数
            KU  N = pq
        则加密 M < N:
            C = M^2 mod N
        解密
            m1 = +- C^{(p+1)/4} mod p
            m2 = +- C^{(q+1)/4} mod q
            a = p (p^{-1} mod q), a equiv 0 mod p, a equiv 1 mod q
            b = q (q^{-1} mod p), b equiv 1 mod p, b equiv 0 mod q
            M = am1 + bm2
        原理
            考虑设 M = a' p + b' q
    Goldwasser Micali 方法
        有
            KR  p q 素数
            KU  N = pq, z 是 QNR^{+1}
        则加密 M in {0,1}
            C = z^m x^2,  x 是随机选取的
        解密
            如果 C 是模 N 二次剩余, 则 M = 0
            否则 M = 1

ElGamal 加密
    概率性的公钥算法
    基本设置
        有
            p     素数
            alpha Z_p 原根
            a     随机
            beta  = alpha^a mod p
        则
            KU = p, alpha, beta
            KR = a
    加解密
        E_{KU}(m, k) = (alpha^k mod p, m beta^k mod p),   k 是秘密随机数
        D_{KR}((c1, c2)) = (c1^a)^-1 c2

------------------------------------------------------------------------------
数字签名 - MAC
    都可以保证消息完整性
    数字签名:
        不可抵赖
        因为使用公钥算法, 慢 100 倍以上

数字签名 - 加密
    签名使用私钥, 加密使用公钥

签名方法
    直接使用 m 签名:
        無消息攻击  按照签名伪造消息
        m1, s1; m2, s2 --> m1m2, s1s2
    如上, 解决: 对消息 hash 之后签名

RSA 签名
    直接使用私钥加密即可,
    签名
        sign(m) = gamma
            gamma = m^d
    验证
        verify(m, gamma)
            v1 = gamma^e
            assert v1==m
    问题:
        無消息攻击: 可以按照签名伪造消息
        乘积攻击: m1 m2 的签名是 s1 s2, sx 是 mx 的签名
    解决:   签名 = H(M)^d,  H 是抗碰撞的 Hash 函数

ElGamal
    签名
        sign(m, k)   =   (gamma, delta)       k 随机, 和 p-1 互素
            gamma = alpha^k mod p
            delta = (m - a gamma) (k^{-1} mod p-1)
    验证
        verify(m, gamma, delta)
            v1 = alpha m mod p
            v2 = beta^gamma gamma^delta mod p
            assert v1==v2
    唯公钥伪造
        有
            i,j < p-1
            j \perp p-1
        令
            gamma = alpha^i beta^j mod p
            delta = -gamma j^{-1} mod p-1
            m = -gamma i j^{-1} mod p-1
    解决: 对消息的 hash 签名
