******************************************************************************
传输的类型
    点对点 (单播)
    广播

按尺度分类网络
    PAN (Personal Area Network) 个域网
        蓝牙
    LAN局域网
        无线局域网 / IEEE 802.11 / WiFi
            计算机和 AP 无线路由器 通信
        交换以太网
            计算机连接到交换机, 和交换机通信以完成数据交换
    MAN
    WAN


分层网络
    概念    - 协议栈
            - 协议
            - 对等体
            - 接口
            - 服务
            - 网络体系结构  层和协议的集合

报文交换有两种
    存储转发式交换:     先收到整个报文, 再转发
    直通式交换:         还未收到整个报文就转发

服务, 协议和接口
    是不同的概念
    服务
        这一层能做什么
    接口
        上一层应当如何访问这一层, e.g. 有什么参数, 什么结果
    协议
        这一层内部是如何实现对等体通信的

参考模型
    OSI RefModel
        OSI 参考模型不是一个网络体系结构!
        从上到下
            应用层
                给用户提供应用
                交换单元:   APDU
            表示层
                控制信息的表示
            会话层
                允许建立会话
            传输层
                交换单元:   TPDU
                提供端到端的可靠传输
            * 以下的都属于通信子网
            网络层
                提供端到端的比特传输
                交换单元:   数据包 packet
                包含
                    路由选择
                    拥塞控制
                    连接不同类型的网络
            数据链路层
                提供链路两端的可靠的传输
                交换单元:   帧 frame
                包含
                    检错纠错,
                    流量控制,
                    广播共享信道控制 (这个是介质访问控制子层)
            物理层
                提供链路两端的不可靠的原始的比特传输
                交换单元:   比特
    TCP/IP RefModel
        主要的目的: 可互联性, 可靠性, 允许多种服务类型
        使用数据包交换网络
        应用层
            协议
                TELNET
                FTP
                SMTP
                DNS
                HTTP
        传输层
            允许源主机与目标主机上的对等实体进行通话
            协议
                TCP     可靠的面向连接的, 抽象为比特流
                UDP     不可靠无连接的
        互联网层
            对应网络层
            使数据包独立到达接收方 (顺序控制由上层提供)
            协议
                IP
                ICMP
        链路层
            不等同于 OSI 的数据链路层
            协议
                DSL
                SONET
                802.11 WiFi
                Ethernet

******************************************************************************
数据通信基础
    Nyquist定理
        有限带宽 B Hz, 无噪声的信道, 信号包含 V 个离散等级
            最大数据速率 = 2 B log_2 V
    信噪比
        SNR = 10 log_10 S/N     (dB)
        e.g. 电话系统: 30 dB
    香农公式
        有限带宽 B Hz, 信噪比 S/N
            最大比特率 = B log_2 1+S/N
    波特率
        信号每秒变化的速度, 亦称调制速率
        e.g. 每个信号值可以表示3位, 则 比特率 是 波特率 的3倍

数据编码
    数字数据的数字传输 (基带传输)
        方式: \graphics{linecode}
            - NRZ
                容易出错, 需要同步
            - Manchester
                能够自同步
    数字数据的模拟传输 (频/通带传输)
        方式: \graphics{passband}
            - 调幅, 调频, 调相
    模拟数据数字传输
        PCM
        按照Nyquist采样
        - 将 f(t) 分成 2^n 级, 数字传输级数
        - 传输 f(t) 的差分
        - 根据每个采样值和前一个差 +-1, 决定传输 0 还是 1

多路复用
    时分复用
        主要用于数字传输
        T1 传输, 1.536 Mbps
    频分复用
        将频率分为多部分
    波分复用
        主要用于光纤传输
        将波长分为多部分

通信方式
    数据信道和监视信道
    - 单工
    - 半双工
    - 全双工

数据传输方式
    - 异步
        信息以字符为单位传输
        效率较低
    - 同步
        信息以报文为单位传输
        效率较高
        SYN     SYN     DATA    SYN     SYN

通信交换
    - 电路交换 circuit switching
        先建立物理链路 (花费时间较长和)
        之后传输延时较小
    - 报文交换 message switching
        报文: 逻辑上完整的信息段
        信息以报文为单位存储转发
        线路利用率高, 延迟大
    - 分组交换 packet switching
        分组: 将报文分成更小的块
        分组在网络上存储转发, 在目标合并成报文
        线路利用率高, 延迟小, 需要传输额外信息
        - 数据报交换
            每个分组有完整的目标地址和源地址
            各个分组可能走不同的路径
        - 虚电路
            传输前建立虚电路
            传输直接沿着虚电路
            最后拆除虚电路

******************************************************************************
物理层接口
    目标: 在网络设备之间提供透明的比特流传输

    特性
        1. 机械的
            引脚数目 etc
        2. 电气的
            电压范围, 阻抗, 传输距离限制 etc
        3. 功能的
        4. 规程的
            工作时序

    传输介质
        双绞线
        基带/宽带同轴电缆
        光纤
            光网络
                点到点: 4根线 (2根保护倒换)
                环: 2根线 (1根保护倒换)

    SONET
        采用 TDM 技术
        传输速率: 51.84 Mbps
        基于字节复用
        同步传输

******************************************************************************
数据链路控制
    目的: 两台 [相邻] 机器实现 [可靠有效] 的 [完整信息块] 的传输
    提供服务
        无确认, 无连接: 以太网              -> 错误率低 / 实时通信
        有确认, 无连接: 802.11 WiFi         -> 不可靠的链路
        有确认, 有链接: 卫星信道, 长途电话  -> 长距离而且不可靠的链路

    成帧 framing
        描述帧的开始和结束:
            1. 字节记数法
                利用帧头部的一个字段描述整个帧的长度
            2. 字节填充的标志字节法
                增加标志字节 FLAG 来标识帧的开始和结束
                增加转移字节 ESC 在帧的数据内部转移 ESC 和 FLAG
                \graphics{bytestuff}
            3. 位填充
                帧的开始使用位模式  0111 1110  来标识
                帧中一旦出现 5 个连续的1, 马上后加0填充
                HDLC协议
                \graphics{bitstuff}

    差错控制
        发送帧时,
            帧头加上负载的校验码
            帧编号, 区分重发帧和新帧
            要求接收方发送确认帧
            发送方使用计时器, 超时重发

    流量控制
        确保慢速接收方不被快速发送方淹没
        基于反馈
        事实上主要在传输层完成

    纠错和检错
        n = m + r
        纠错
            差错很频繁的信道
            * Hamming码
                2^r各校验位模式表示2^r中错误模式
                检测某一位错误
                m + r + 1 <= 2^r
        检错
            可靠的信道
            * 奇偶校验位
                奇数个错误
            * CRC
                生成多项式 G(x) 高位和低位必须为1
                校验和加在帧尾, 使得带校验和的帧能被 G(x) 整除
                多项式除法系数是 Z_2 域
                一般硬件实现
                \graphics{crc}

协议
    捎带
        双工传输中, 确认帧直接附在数据帧中
        滑动窗口协议都使用捎带
    要求帧号的全集构成一个环
    WS: 发送窗口, 其中的帧号都是已经发送的帧的帧号
        [最小的<已发送且未确认的>帧帧号,
        准备发送的下一帧的帧号)
    WR: 接收窗口, 其中帧号都是未接受的帧的帧号
        WR.low-1 是最大的已经接受的帧帧号
        [最小允许接受帧帧号, WR.low + WR.size)
        (接收窗口的大小是固定的)
    1 位滑动窗口协议
        接受窗口大小总为 1
        seq in Ring[0, 1]

        最初
            WS ::= [0, 0)
            WR ::= [0, 1)
            WR.size ::= 1
        发送初始帧寸后
            WS = [0, 1)
            WR = [0, 1)
        接收到一个帧 <seq, ack>
            处理接受    (WR)
                // ASSERT WR.size = 1
                IF seq in WR        (* i.e. seq = WR.low *)
                    forward frame to network layer
                    WR.low++
                    WR.high++
                ELSE
                    // discard
            处理ack     (WS)
                // it does not matter even if WS.size = 0
                IF ack = WS.low
                    stop timer <WS.low>
                        // send new frame and piggyback
                    send frame <seq=WS.high, ack=WR.low-1>
                    start timer <WS.high>
                        // update WS
                    WS.low++
                    WS.high++
                ELSE
                    // resend all unack'd frames
                    send frame <seq=WS.low, ack=WR.low-1>
                    restart timer <WS.low>
                    // discard recv'd frame
        <seq> 超时
            // ASSERT seq = WS.low
            send frame <seq=seq, ack=WR.low-1>
            start timer <seq>
        问题
            如果双方同时开始传输, 那么就会出现 50% 的信道浪费!
            因为收到对方传输过来的第一个包时,
            自己已经发送了一个包给对方
            因此自己会希望对方捎带确认自己发送的包
            但是对方发送时并没受到自己发送的包 (同时发送)
            因此捎带确认失败, 之后会重新发送这个包
            但事实上对方已经收到了这个包了
        效率
            效率很低, 有下分析
            BD ::= 带宽 * 单向传输时间 / 帧大小
                意义是, 链路上能容纳多少个包
            链路利用率
                <= w / (1 + 2 BD)
            其中 w 是窗口技术

    回退 N 协议
        保持至多N个帧同时传输
        某个帧出错就卡住不接受后续帧, 知道接收到正确的这个帧
        而且!! 只接受窗口下沿的帧 i.e. 只接受 (seq = WR.low) 的帧
        一次发送数据到另一次发送之间可能接受多个帧,
            这样第二次发送的时候 ack 置为最大的
            约定 ack 即确认了所有小于等于 ack 的未确认帧
        有多个计时器, 但是超时重传所有帧

        要求 seq in Ring[0, N+1)
            因为一次可能有 0, 1.. N-1 个编号
            如果是Ring[0, N),
            那么发送这么多之后 WS 就变成 [0, 0) 了

        最初
            WS ::= [0, 0)
            WR ::= [0, 1)
            WR.size ::= N
        发送初始帧寸后
            WS = [0, 1)
            WR = [0, 1)
        有一个新的帧要发送
            // ASSERT WS.size < N
            send frame <seq=WS.high, ack=WR.low-1>
            start timer <WS.high>
            WS.high++
        接收到一帧 <seq, ack>
            处理接受
                IF seq = WR.low
                    forward frame to network layer
                    WR.low++
                    WR.high++
            处理ack
                // it does not matter even if WS.size = 0
                while ack in WS
                    stop timer WS.low
                    WS.low++
        超时
            for seq in WS
                send frame <seq=seq, ack=WR.low-1>
                restart timer seq

    选择重传
        接收窗口有 NR 大小
        接收到非窗口最小帧号的帧, 先暂存

        允许 NAK 帧 (NAK 一般只针对 WR.low)
        允许单独的 ACK 帧 (不用总是捎带)

        is_nak_sent
            针对 WR.low 是否已经发送 NAK

        seq in Ring[0, N+1)

        要求 NR <= (N+1) / 2
            ->  同时最多有 6 个未确认的帧 WS <= 6
                帧号范围是 0~7
                接受窗口大小为 4

        send frame 隐含包含 start timer
        acknowledge 隐含包含 stop timer

        最初
            WS ::= [0, 0)
            WR ::= [0, NR)
            WR.size ::= NR
            recvd[] := FALSE
        接收到一个帧 <TYPE, seq, ack>
            TYPE 为 DATA
                if seq != WR.low    AND
                        NAK not already sent for current WR.low
                    // urge for WR.low
                    send frame <NAK, seq=0, ack=WR.low-1>
                else
                    start timer <ACK>
                if seq in WR        AND     NOT recvd[seq]
                    recvd[seq] := TRUE
                    save frame <seq>
                    while recvd[WR.low]
                        recvd[WR.low] := FALSE
                        load frame <WR.low>,
                            and forward to network layer
                        WR.low++
                        WR.high++
                        start timer <ACK>
            TYPE 为 NAK
                if ack+1 in WS
                    send frame <DATA, seq=ack+1, ack=WR.low-1>
            无论什么 TYPE
                一定有 ack 信息, 更新 WS
                while ack in WS
                    acknowledge WS.low
                    WS.low++
        准备发送一帧的数据
            // ASSERT WS.size < N
            send frame <DATA, seq=WS.high, ack=WR.low-1>
            WS.high++
        校验和错误 (网卡直接发现校验和错误)
            if NAK not already send for current WR.low
                send frame <NAK, seq=0, ack=WR.low-1>
        <seq> 超时
            send frame <DATA, seq=seq, ack=WR.low-1>
        <ACK> 超时
            send frame <ACK, seq=0, ack=WR.low-1>

******************************************************************************
协议工程研究的范围
    - 协议说明（Protocol Specification）
        定义一个协议实体提供给它的用户的 [服务]，
        又定义该协议实体的 [内部操作]
    - 协议验证（Protocol Verification）
        验证协议说明是否完整, 正确
    - 协议实现（Protocol Implementation）
        用硬件/软件实现协议说明中规定的功能
    - 协议测试（Protocol Testing）
        测试的方法来检查协议实现是否满足要求
        * 一致性测试
        * 互操作性测试
        * 性能测试

有限状态机模型
    ...

Petri网模型
    ???

HDLC
    使用HDLC的语法事实上可以定义多种协议
    ???

???
******************************************************************************
局域网技术
    局域网: 将小区域内的各种通信设备互连在一起的通信网络

    局域网拓扑结构
        星型结构
        环型结构
        总线型结构
        树型结构

    传输介质
        双绞线
        基带同轴电缆
        光纤
        无线

******************************************************************************
介质访问控制子层
    静态分配
        适用于用户较少, 数目固定, 且用户通信量均衡的情况
        TDM
        FDM/WDM

    目标: 在共享信道 (广播信道) 上传播消息

    动态信道分配假设
        - 流量独立
        - 单信道
        - 冲突可观察    (发生冲突后所有人都能知道)
        - 时间连续/离散
        - 载波监听/不听 (是否能检查信道忙)

    多路访问协议
        ALOHA
            1. 有数据, 立刻传输
            2. 如果冲突, 等待随机时间后转1., 直到没有冲突
            冲突危险区
                在t0时刻发送的帧, 冲突危险区是 t0 - T 到 t0 + T
                \graphics{aloha}
            效率: 最好信道利用率 18.4% = max{G e^{-2G}}
                其中 G 为假定每个帧时,
                    新旧产生的帧数是 Poisson 分布 G 个
        离散ALOHA
            和ALOHA相同, 但是传输数据总发生在离散时间片的开始段
            效率: ALOHA2倍 最好信道利用率 36.8%
        载波监听协议 CSMA
            要求: 载波监听
            * 1-坚持载波检测多路访问 1-persistent CSMA
                1. 有数据, 监听信道
                    如果信道忙, 等到信道不忙之后, 立刻传输
                    否则立刻传输
                2. 如果冲突, 等待随机时间后传1.
            * 非坚持载波检测多路访问 non-persistent CSMA
                1. 有数据, 监听信道
                    如果信道忙, 等待随机时间后转1.
                    否则立刻传输
                2. 如果冲突, 等待随机时间后传1.
                相对于1-persistent, 冲突率减少, 延迟增大
            * p坚持载波检测多路访问 p-persistent CSMA
                要求: 时间离散
                1. 有数据, 监听信道
                    如果信道忙, 等到下一时间片转1.
                    否则, 按照p概率发送数据, 1-p概率等到下一时间片转1.
                2. 如果冲突, 等待随机时间后传1.
            冲突检测载波监听 CSMA/CD
                边发送便检测, 当检测到冲突后,
                放弃当前帧传输, 而非等待传输完成
        最坏情况下, 检测到冲突需要花费 2 倍最远传输时间

    无冲突协议
        位图协议
            基本思想: 信道的使用分为两部分
                1. (竞争) 各个发送者申请使用
                    此阶段为离散时间, 有N个发送者就消耗N个时间片
                    每个时间片, 有且仅有对应发送者广播自己是否有数据发送
                2. (发送) 发送数据
                    按照发送者序号顺序, 发送数据
            参见图4-6
            特点: 高负载情况下信道利用率更高
                高序号的站点占优势 (可以在申请过程的中途决定发送数据)
        令牌环
            - 发送者排成一个环, 环中有一个令牌一直在传递
            - 发送者只有在自己持有令牌时, 才能发送数据
            - 发送者发送完所有数据, 将令牌传递给下一个发送者

    有限冲突协议
        自适应树
            基本思想: 信道的使用分为竞争和发送两部分
                发送者作为树的叶子
            参见图4-10
            竞争部分可以从树的不同深度开始, 以适应不同负载

    WLAN协议
        无线网络: 不能检测冲突
            不是完全的广播, 而是只能收到/发给靠近的结点
        问题:
            隐藏终端 (接受者实际发生冲突)
            / 暴露终端 (发送者实际不冲突)
        解决: 避免冲突的协议 MACA
            - 发送者发送 请求发送帧, 包含发送数据长度
                发送者 影响范围内所有人一定时间内静默,
                保证 允许发送帧 回到 发送者
            - 接收者接受 请求发送帧 后发送 允许发送帧, 包含发送数据长度
                接收者 影响范围内所有人一定时间内静默
                保证 数据 传送给 接收者
            - 发送者发送数据
            - 如果还冲突, 等待随机时间后从头开始

******************************************************************************
以太网
    MAC子层
        目标
            数据帧封装, 发送和接受
                成帧
                寻址 (源/目的 MAC地址 处理)
                差错检测
            介质访问处理
                在共享信道上发送信息
    LLC子层
        目标: 提供确认机制和流量控制
        位于数据链路层, 在 MAC 层之上
        服务
            不可靠数据报服务
            有确认数据报服务
            可靠的面向连接的服务

    经典Ethernet
        使用一根电缆将设备连接, 电缆有长度限制
        利用中继器: 物理层设备. 对信号进行接收, 放大和双向重传
            可以延长传输距离
        以太网 MAC子层帧格式
            len/B | 8         | 6 or 2   | 6 or 2   | 2       |
            field | PREMABLE  | DESTADDR | SRCADDR  | TYPE    |
            +++++++++++++++++++++++++++++++++++++++++++++++++++
            len/B | 0 to 1500 | 0 to 46  | 4        |
            field | DATA      | PAD      | CRCCKSUM |
        IEEE 802.3 的格式和 以太网 格式稍有不同
            PREMABLE    分为 PERMABLE (7) 和 SOF (1)
            TYPE        变为 DATALEN
        802.3 / Ethernet 采用
            * 1-坚持的 CSMA/CD,
            * Manchester 编码
        MAC帧格式
            PREMABLE和SOF都是确定的值
            ADDR 长度是 6 位
        最短帧长
            为了 CSMA/CD 工作, 需要当帧完全布满介质时仍在发送 (监视)
            因此最小发送时间是 2 tau, tau是最长延迟时间 (对于电缆,
                就是电缆长度除以信号传播速率)
            对于 10 Mbps LAN,
                最短帧长是 64 字节 (从 DESTADDR 算起知道 CRCCKSUM)
                时间被定为 51.2 us
        二进制后退算法
            一旦发生冲突, 将之后的时间划分为 51.2 us 为单位
            第1个冲突后, 诸站点等0或1个时间单位传输
            第k次冲突后, 等待 0..min(2**k-1, 1023) 个单位
            16次冲突后, 失败报告上层

    交换式以太网
        是事实上的现在以太网的标准, 更加高速
        目的: 在很多主机时, 减少冲突
        经典以太网的设备: 集线器 (简单的讲线缆集合到一起)
        交换以太网的设备: 交换机
            交换机知道每个端口对应哪些 MAC 地址
            交换机各个端口进来的帧不会冲突,
            即使同时有多个帧发送到同一个端口,
                交换机也会完成缓存
    快速以太网
        经典的10Mbps以太网太慢
        快速以太网: 100 Mbps
        将电缆最大长度降低到原来的 1/10
    千兆以太网
        1000 Mbps

******************************************************************************
令牌环 IEEE 802.5
    类似 Ethernet 是一种实现LAN的技术
    组成
        不是一个共享介质,
        而是 N 台计算机组成一个环, 使用点到点链路连接
    令牌:
        一个节点要发送时, 取得令牌
        发送完成再将令牌还给环路
    提供确认等功能

******************************************************************************
数据链路层交换
    交换:
        连接不同的局域网, 允许数据在不同局域网之间交换
        可以互联不同类型的局域网
        (可能有的帧无法转发, 采取直接丢弃的方法)
    网桥: 位于数据链路层,
        审查帧的数据链路层地址 -> 不受上层协议限制
    学习网桥 / 透明网桥
        无需配置
        帧:     记为<SA, DA, II>
            源地址      SA,
            目标地址    DA,
            载荷        payload,
            输入端口    II
        哈希表: 记为DA -> OI
            目标地址    DA,
            输出端口    OI
        - 源地址为SA的帧从端口II进入,
            发送:
                哈希表中无DA项:
                    OI未知
                    广播到所有端口 (II除外)
                    称为洪泛
                有:
                    如果 OI 等于 II, 则不转发 (同一个局域网内)
                    否则转发到 OI
            更新:
                SA -> II
                称为后向学习
    生成树网桥
        问题: 冗余配置, 网桥出现了环路 (网桥为结点的环路), 无限洪泛
        生成一颗分布式的最小字典序的BFS树
        算法
            1. 选择 ID (事实上就是MAC地址) 最小的网桥作为根
            2. 每个网桥选择一条到根的最短路,
                有多条则选从这个节点开始下一跳 ID 最小的最短路
            3. 不停重复以上算法, 以适应网络拓扑的改变
    源路由网桥
        Ethernet (CSMA/CD), Token Bus: 生成树/透明网桥
        Token Ring: 源路由网桥
        算法
            如果目标不在自己的Token Ring中, 构造序列
                <LAN1, BRIDGE1, LAN2, BRIDGE2 ... LANk>
            为发送帧的路由序列
            求路由序列是通过源地址请求网桥,
                之后网桥广播
                目标站应答
                网桥附加应答
            得到的
        问题
            网桥的插入变得不透明
        好处
            一定走最优路径

******************************************************************************
网络层和路由选择

网络层
    目标: 网络内两个实体的信息交换
    端到端传输的最低一层 i.e. 跨越多个链路
    通信子网的最高一层

    实现
        虚电路
            路由器需维护电路; 需要建立连接; 脆弱
        数据包
            数据报包含完整地址; 需要路由; 更可靠

    服务
        面向连接 / 无连接
        注意,
            通信子网的服务类型 i.e. 下层的服务类型 (IP/ATM)
            不影响网络层向上层提供的服务类型

网络层和路由选择
    最底层, 能够处理端到端的 (链路层: 只是从某链路一边至另一边, 不涉及路由中继)
    关键问题
        - 了解通信子网的拓扑结构
        - 选择路由
    为传输层提供的服务
        - 有连接的
        - 无连接的
    内部组织
        - VC        虚电路
            路由维护所有VC的状态
            建立连接花费时间
            容易保证QoS
        - datagram  数据包
            每个包都需携带完整的目标/源地址
            每次转发包时过程复杂
            不易保证QoS
            对于线路故障适应性强
    注意, 有无连接和VC/Datagram没有必然联系


路由算法
    入境包应被发送到哪条出境线路
    要求
        - 正确
        - 简单
        - 鲁棒
        - 稳定
        - 公平
        - 高效
    分类
        - 适应性的
            根据网络拓扑, 包括通信压力, 改变路由选择
        - 非适应性的
            i -> j 的路由选择是离线计算的, 在网络启动时分配给诸路由
            无法应对差错 -> 第一路由, 第二路由 ...
            对于小网络常用
    最短路方法
        Dijkstra等
            不能应对路由故障
    Flooding 洪泛
        所有入境包被发送到所有出境线
        改进: 限制跳数 -> 指数级别的代价
              各个路由不重复发
              只把包发送到和目标方向接近的出境线上
        非常可靠
        问题: 重复包太多
    基于流量的路由算法
        前提: 每对节点 <u, v> 之间流量是稳定的
        思想: 同时考虑拓扑结构和网路负载, 最小化平均包延迟
    Distance Vector Routing
        RIP协议
        每个路由维护一个表
            目标 -> 目前已知的到目标的最短路, 此最短路对应出境线路
            对于每个节点u:
                到邻居v的距离是 w_uv
                邻居到w的距离是 TABLE[v][w].dist
                如果 w_uv + TABLE[v][w].dist < TABLE[u][w].dist
                    更新
        实质是分布式的Bellman-Ford算法
        时间节点的选择
            - 周期性
        能够很好适应故障节点上线 (good news travels quickly)
        count-to-infinity 问题:
            如果某路由v故障, 只有邻居u能知道 w_uv 变成无穷
            但是其他路由的 w_uv 没有更新, 是错误的w_uv
            虽然bellman ford保证最后 w_uv 会收敛到无穷, 但是结果可能很漫长
            (bad news travels slowly)
    Link State Routing
        在某个时间节点, 每个路由u执行
            1. 发现所有邻居v, 以及期间距离 w_uv
                点到点发送 HELLO 包 / 返回 HELLO_RESP 包
                发送 ECHO 包
            2. 给所有路由发送包, 包含 u到所有邻居v的距离 w_uv
            3. 接受所有的 w_st
            4. 局部执行Dijkstra算法, 计算TABLE[u][w].next
        实际上就是分布式的Dijkstra算法
        时间节点的选择:
            - 周期性
            - 网络拓扑改变时
        引用
            IS-IS
            OSPF
        问题
            震荡: 路由时断时续
            健壮性: 每个结点只计算自己的路由表
    Hierarchical Routing
        网络越大, 路由需要的存储/计算越多
        将整个网络分成不同区域, 每个区域内所有路由是互联的
        每个区域的路由, 对于其他区域的路由, 由其区域代表
        -> 每个区域再分成不同的子区域
        (network -> region -> cluster -> zone -> group ...)
    #   Broadcast Routing
    #       朴素: 源发送包给所有目标 (i.e. 网络中所有其他节点)
    #       multidestination routing:
    #           每个包包含一系列地址 (而不是单个地址)
    #           仍然需要源知道所有目的
    #       flooding:
    #           改进, 每个点只洪泛一次
    #       reverse path forwarding
    #           维护网络的一颗生成树, 只洪泛从父亲过来的包
    #   Multicast Routing
    #       假设多播组地址已知, 最简单的方法是沿用广播路由方法的生成树方法
    #       改进:   将广播生成树对于不同的多播组剪枝, 得到多播生成树
    #       剪枝方法:
    #           如果路由知道网络结构, 则直接简单地计算即可
    #               -> MOSPF
    #           如果路由不知道, 可以递归剪枝
    #               如果节点本身 / 所有儿子没有某多播组成员, 面对多播要求返回 PRUNE 信息
    #               -> DVMRP
    移动主机的路由
        移动用户
            位置发生变化接入网络
        Home Location
            所有用户 (含移动用户) 有一个永久的 Home Address
        Foreign Agent
            每个区域有外部代理, 记录该区域内的移动用户
        Home Agent
            每个区域记录 Home 在此区域, 但是在其他区域的用户
        方法
            移动用户进入某区域
                在Foreign Agent注册
                Foreign Agent和Home Agent确认
        当一个包发送给移动用户
            首先转发到家乡 LAN
            家乡代理采用隧道将包发送给外部代理
            外部代理发送给移动用户
            家乡代理告诉包发送者,
                此后直接 (隧道) 发送给外部代理


拥塞控制算法
    拥塞:   网络信道上有太多包
    原因:   处理器慢 / 线路带宽窄

    和流量控制的区别
        拥塞:   全局性问题, 涉及主机/路由等
        流量:   点到点/端到端, 只涉及两个主机

    控制算法
        开环控制
            通过好的网络设计
            与网络当前状态无关
        闭环控制
            基于反馈, 基于当前网络状态
            反馈: 向负载产生源发送报警包
                周期性地检查是否拥塞

    衡量网络拥塞的参数
        丢包率; 重传包的数目;
        平均包延迟;
        路由中包队列长度;
        包延迟的抖动

    流量整形
        原理: 拥塞情况通常是因为流量burst出现
        方式: 强迫包的发送速率是可预测的
        漏桶算法
            类似向底部有漏洞的木桶中以有burst的速率加水
            底部漏水速率不会有burst
        令牌桶算法
            每隔固定时间给发送方一个令牌,
            允许发送一定量的数据
            令牌数目有最大值
            \graphics{token-bucket}

    虚电路中拥塞控制
        许可控制:   发生拥塞时, 不允许建立新的虚电路
                              / 新的虚电路需要绕开拥塞区域
                              / 建立虚电路时, 子网需要预留空间
        抑制包:     路由器监控线路等状态, 利用率太高进入预警状态
                        主机向预警线路上发送包时, 路由器警告主机
                        要求主机减少发送速率
                              / 只作用于主机
                              / 作用于沿途所有路由器
        公平队列:   路由器有多个输出队列, 路由器循环扫描各个队列,
                        发送队列头
        负载丢弃:   最后的方法
                        可能有不同的丢弃策略: 优先丢弃新报/旧包


网络互连
    级联虚电路
        当目的主机不在子网内时,
            在子网内找一个离目的主机最近的路由,
            建立源主机到它, 它到目的主机的虚电路
        特点
            可以预留资源等虚电路优点
            健壮性差, 不抗拥塞
            路由需要大量内存
    无连接网络互连
        需要在连接不同子网的多协议路由器中, 做协议转换
        特点
            健壮性好
            包头长
            包到达无序
    隧道技术
        源主机和目的主机的网络类型相同
        直接将IP包作为载荷传输

    分段:
        透明: 中间网关做
            反复重组分段开销大; 所有分组需要从同出口网关
        不透明: 主机做
            每个包都有一个包头, 网络开销变大

    防火墙
        目的:   防止网络中信息泄露, 防止外部信息渗入
        可以在路由器中实现,
            实现IP包过滤
        还可以在应用网关中实现
            实现应用层信息审查

    Internet网络层协议
        IP协议: 包头长20 ~ 60字节
            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |Version|  IHL  |Type of Service|          Total Length         |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |         Identification        |Flags|      Fragment Offset    |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |  Time to Live |    Protocol   |         Header Checksum       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                       Source Address                          |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                    Destination Address                        |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                    Options                    |    Padding    |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            TOTALLEN:   2字节, 意味着 IP 包顶多 65536 字节长
            IHL:        4位, 但是合法的值是从5开始 (5个32位字)
        IP地址:
            组成: 网络号 network (包含子网) + 主机号 Host
                全0表示本地, network=全0表示本局域网
                全1表示广播, network!=全1表示某另外的局域网广播
            子网: 将网络内部继续分化成若干区域
            最初: 地址分类 (A类地址 ... E类地址)
            修正: 无类别地址 (subnet mask是对于 network 整体的掩码)
        ICMP
            主要用于报告和测试
            被封装在IP包中
        ARP
            完成IP地址到MAC地址的映射

    互联网路由
        两极路由算法
            第一级: RIP / OSPF; 在自治系统内部
            第二级: BGP;        在自治系统之间
        RIP协议
            距离向量算法    [<dest, n_hops, next_hop>]
            距离的衡量采用跳数
            距离向量是每30s交换1次,
            180秒还未收到邻居的距离向量就认为邻居宕机
                该邻居距离无效
                采用poisonous reverse完成count to infinity问题
        OSPF协议
            将路由器作为结点得到有向图网络
            可以将网络也作为结点
        每个自治系统内部划分区域, 所有区域和主区域0连接
        BGP协议
            AS之间路由
            重要问题是策略, 如谷歌的流量不能从苹果公司路由
            效率不重要: 不关心最短路
            采用 path vector 方法,
                每个 BGP 网关向邻居广播通向目的地的路径
            由邻居决定是否选择X提供的路径

    CIDR
        IP地址不再分为A类, B类, C类等
        路由的时候在考虑一个掩码即可,
            表明地址的网络部分 (和主机部分分开)
            记为 x.x.x.x/x
        最长匹配原则:
            路由查找时, 同样匹配, 掩码前导越长越好

    IPv6
        - 地址变成128位
        - IP头简化: 变成7个域
        - IP头变成定长的
        - 更好支持安全性
        - 注重TOS
        包结构
            VER     | PRIORITY | FLOWLBL |
            PLDLEN  | NEXTHDR  | HOPLMT  |
            SRCADDR |
            DSTADDR |
            PRIORITY: 拥塞时, 优先级
            FLOWLBL: 用来实现伪连接
            NEXTHDR: 拓展包头, 最后一个才是 PAYLOAD PROTOCOL
        地址表示
            用 : 分割的 8 个, 每个是 \x\x\x\x
            简写:   0123 = 123      ;
                    x::y = x(:0000)+:y ;
                    第二个规则只能用一次, e.g.
        8000:0000:0000:0000:0123:4567:89AB:CDEF
                    变为
                    8000::0123:4567:89ab:cdef
        过渡
            1. 双栈: 路由器同时支持 IPv4 和 IPv6
            2. 隧道: IPv6 包作为 IPv4 的载荷
******************************************************************************

传输层
    目的
        消除网络层的不可靠性
        提供端到端主机的可靠的, 对网络类型透明的信息传输
        尤其管理连接建立释放等
    服务类型: 有连接 / 无连接
        (即使网络层是有连接的, 传输层也可以是无连接的)
    传输服务提供者:
        物理层, 链路层, 网络层, 传输层
    数据单元
        称为segment段,
        或者 TPDU

    例子
        Berkley Socket
            释放链接是对称的, 需要双方执行 disconnect
            原语:
                socket  初始化socket
                bind    绑定到地址
                listen  初始化入境队列, 允许监听 (非阻塞)
                accept  阻塞等待下一个入境链接
                connect 连接到远程系统
                send    发送数据
                receive 接受数据
                close   请求关闭连接
                sendto  发送到
                recvfrm 接收到

    寻址
        TSAP: 传输层端到端的一个端
        每个主机认为有一个NSAP,
            但是可能有多个TSAP, 基本类似IP地址和端口号
        TSAP 事实上就是 <IP, port>
        对于某远端主机, 希望获取某应用程序的 TSAP
            1. 约定, 如 80 / HTTP
            2. 从 name server 或者 directory server 获取
                其是在远端主机的某一确定的端口上
                将服务名称提供给他 (如"ssh")
                他返回一个端口
        端口号的分配:
            确定的协议
            portmapper: 服务名 -> 端口
        初始连接协议 initial connection protocol:
            服务进程很多, 但是每一个都很少活动
            不用每一个进程一直监听一个端口, 而是动态分配
            仅当有请求时, 才唤醒服务进程绑定到某端口上

    建立连接
        理想情况:
                CONNECTION REQUEST
           src ---------------------> dst
               <--------------------
                CONNECTION ACCEPT
        问题: 网络不可靠
            网络可能丢失 / 延迟包, 如遇到拥塞
        解决: 多次握手方法
            参见Fig. 6-11
            \graphics{estab-handshake}

    释放连接
        理论基础: 不存在完全可靠的释放连接方法
        方法: 多次握手
            参见Fig. 6-14
        \graphics{disconnect-handshake}

    错误控制
        通过类似链路层的 停等/滑动窗口协议 实现
        区别链路层为, 链路是点到点的没有跳数, 传输层是端到端的跳数不小
        -> 耗时更长, 一般采用更大的窗口大小
    流量控制
        如上采用滑动窗口
        避免丢失控制TPDU: 周期性发送

TCP
    TSAP通过 IP地址:port端口 表示

    特点
        基于字节流, 消息的边界不能被保留
        不支持多播和广播
    通过双方创建套接字来完成的
        套接字是全双工的
    错误/流量控制
        滑动窗口/可变滑动窗口
        慢启动: 最开始慢发, 逐渐提高发送速度
    链接管理
        建立: 3次握手
        释放: 3次握手 / 定时器

    TCP 被包含在 IP 载荷中, 帧头格式
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    其中
        Sequence Number 和 Acknowledgment Number 用于完成滑动窗口
            滑动窗口确认的是字节, 每个字节用他是本方向第几个传输的字节表示
        Sequence Number: data中第一个字节的 seq
        Acknowledgment Number:  !! 注意是, 下一个期待的字节
        Data offset 即 TCPHDRLEN
        Window 用于 可变滑动窗口的窗口大小, 用于流控
            发送方可以从再 Sequence Number 开始再发送 Window 大小的字节流
    建立连接
        \graphics{tcp-estab}
        只有最初的 [2] 个包是 SYN=1 的
        最初的包的 ACK=0
    释放连接
        发出 FIN=1 的包.
        收到确认或超时后关闭连接
    滑动窗口
        当 Window 减少到 0 时, 就不允许发送数据了
            除非数据是 urgent 的
            或者采用窗口探索, 发送一个长度为1的段
                要求接收方宣告下一个 Window 等
        延迟确认
            不是每收到一个帧就立刻确认
            而是等一会儿, 希望等到捎带确认
        Nagle算法
            如果发送端的数据很少, 一般的方法很低效
            可以: 第一次发送之后, 以后每次,
                输入都缓冲, 直到上一次的确认到达再发送缓冲的输入
            (可能导致死锁, 如果和延迟确认一同使用)
        Clark方法
            如果上层应用每次只取缓冲的一部分,
            不用每次都发送一个帧来告知 Window
                因为告知的这个可发送大小 Window 也不大
            解决方法: 接收方只有当 Window 够大 e.g. 大于缓存一半
                才发送 ACK 更新 Window
    拥塞控制
        1. 快网络, 慢接收
            建立连接时就确认了 TCP segment 的最大长度
            并且有滑动窗口限制发送
        2. 慢网络, 快接收
            发送方不仅知道 接收方的可变滑动窗口,
                    还知道 网络的拥塞窗口 congwin
                        这表示网络能接受的有多少个未确认的包
            - slow start
                congwin ::= 1
                
                until congwin > threshold
                    send congwin segments with maximun segment size
                    if  loss of packet / timeout
                        break
                    congwin *:= 2

            - congestion avoidance
                如果 congwin > 阈值
                    对于每个接收到的ACK, 都 congwin += MAX TCP segment
                    直到丢包超时
                threshold := congwin / 2
                congwin := 1
                运行 slow start

UDP
    无连接, 延迟小
    无状态, 无序
    不可靠, 无拥塞控制

    应用: 流媒体; RIP; DNS; SNTP
    也可以利用UDP搭建可靠的服务 (应用程序自己负责)

    UDP帧头格式
      0      7 8     15 16    23 24    31
     +--------+--------+--------+--------+
     |     Source      |   Destination   |
     |      Port       |      Port       |
     +--------+--------+--------+--------+
     |                 |                 |
     |     Length      |    Checksum     |
     +--------+--------+--------+--------+

******************************************************************************
应用层协议
    进程如何指定他的 peer
        IP 指定主机, port 指定远程主机的进程
    应用层服务的类型
        - 可靠性
            允许数据丢失 音频应用
            绝对可靠     文件传输
        - 带宽要求
            需要一定带宽        多媒体
            需要使用全部带宽  文件传输
        - 延时要求
            要求低延迟 网络游戏
            允许延迟   电子邮件
    C/S 架构
        数据在客户端和服务器间双向流动
        服务器处理并发请求 etc
    例子
        - DNS
            DNS请求以 UDP 发出
            本地DNS完成则返回, 否则向上层DNS请求
        - SNMP
            基于 UDP
        - SMTP
            基于 TCP
            端口 25
        - FTP
            基于 TCP
            端口 21

******************************************************************************
rev

    data link layer:    very important

考试
    1, 2, 3, 4层, 体系结构很重要


习题课
    字符计数:   需要包含字符计数自身, 如
        5 A B C D
    字节填充 / 位填充
        都需要帧两端加上 FLAG
    3.11 行列奇偶校验
        要考虑校验位出现错误的情况
        对于行列校验存在不能检测的三位错误
    CSMA/CD协议需要在发送数据到信道前捕获信道
        即信道端到端传输需要时间最长时间的两倍
******************************************************************************

应用层
各种网线

1. 硬盘, 磁带的 GB 指的是 2**30,
    而网络传输的 Gbps 是 10**9 bits/sec

2. 注意换算 字节和位, 注意大小写

3. 计算数据传输率, 
    要同时计算 Shannon 定理的答案和 Nyquist 定理的答案,
    比较取更小

电路交换
             k 跳;
    一跳延时 d 秒;
    传输率   b 位一秒;
             x 位;
    建立     s 秒;
    时间:
        s    + kd       + x/b
        建立 + 传播延迟 + 最初发送
分组交换 (负载较轻)
             k 跳;
    一跳延时 d 秒;
    传输率   b 位一秒;
             x 位;
    分组大小 p 位;
    时间:
        x/b      + kd       + (k-1)p/b
        最初发送 + 传播延迟 + 存储转发

******************************************************************************
CN - a Top Down approach

>> TCP Congestion Control

In order to focus on congestion control (as opposed to flow control), let us hence-
forth assume that the TCP receive buffer is so large that the receive-window con-
straint can be ignored; thus, the amount of unacknowledged data at the sender is
solely limited by cwnd. We will also assume that the sender always has data to
send, i.e., that all segments in the congestion window are sent.

> Slow start

Thus, in the slow-start state, the
value of cwnd begins at 1 MSS and increases by 1 MSS every time a transmitted
segment is first acknowledged. 

This process results in a doubling of the sending rate every RTT. Thus, the TCP
send rate starts slow but grows exponentially during the slow start phase.

> Congestion Avoidance

Thus, rather than doubling the value of cwnd every RTT, TCP adopts a
more conservative approach and increases the value of cwnd by just a single MSS
every RTT [RFC 5681]. This can be accomplished in several ways. A common
approach is for the TCPsender to increase cwnd by MSS * (MSS/cwnd) when-
ever a new acknowledgment arrives. 
